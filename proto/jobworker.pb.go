// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: jobworker.proto

package proto

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GetJobResponse_State int32

const (
	GetJobResponse_UNKNOWN   GetJobResponse_State = 0
	GetJobResponse_RUNNING   GetJobResponse_State = 1
	GetJobResponse_COMPLETED GetJobResponse_State = 2
	GetJobResponse_STOPPED   GetJobResponse_State = 3
	// The command either failed to start (it never ran) or it started
	// but was terminated unexpectedly (probably signaled)
	GetJobResponse_FAILED GetJobResponse_State = 4
	// The command has not started yet
	GetJobResponse_PENDING GetJobResponse_State = 5
)

var GetJobResponse_State_name = map[int32]string{
	0: "UNKNOWN",
	1: "RUNNING",
	2: "COMPLETED",
	3: "STOPPED",
	4: "FAILED",
	5: "PENDING",
}

var GetJobResponse_State_value = map[string]int32{
	"UNKNOWN":   0,
	"RUNNING":   1,
	"COMPLETED": 2,
	"STOPPED":   3,
	"FAILED":    4,
	"PENDING":   5,
}

func (x GetJobResponse_State) String() string {
	return proto.EnumName(GetJobResponse_State_name, int32(x))
}

func (GetJobResponse_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4fc5f638932919ca, []int{6, 0}
}

type CommandSpec struct {
	Command string   `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
	Args    []string `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	Env     []string `protobuf:"bytes,3,rep,name=env,proto3" json:"env,omitempty"`
	Dir     string   `protobuf:"bytes,4,opt,name=dir,proto3" json:"dir,omitempty"`
}

func (m *CommandSpec) Reset()         { *m = CommandSpec{} }
func (m *CommandSpec) String() string { return proto.CompactTextString(m) }
func (*CommandSpec) ProtoMessage()    {}
func (*CommandSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4fc5f638932919ca, []int{0}
}
func (m *CommandSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandSpec.Merge(m, src)
}
func (m *CommandSpec) XXX_Size() int {
	return m.Size()
}
func (m *CommandSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CommandSpec proto.InternalMessageInfo

func (m *CommandSpec) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *CommandSpec) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *CommandSpec) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *CommandSpec) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

type StartJobRequest struct {
	Command *CommandSpec `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
}

func (m *StartJobRequest) Reset()         { *m = StartJobRequest{} }
func (m *StartJobRequest) String() string { return proto.CompactTextString(m) }
func (*StartJobRequest) ProtoMessage()    {}
func (*StartJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4fc5f638932919ca, []int{1}
}
func (m *StartJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartJobRequest.Merge(m, src)
}
func (m *StartJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartJobRequest proto.InternalMessageInfo

func (m *StartJobRequest) GetCommand() *CommandSpec {
	if m != nil {
		return m.Command
	}
	return nil
}

type StartJobResponse struct {
	// JobUUID specifies the job's UUID in its standard hexadecimal
	// representation.
	JobUUID string `protobuf:"bytes,1,opt,name=job_uuid,json=jobUuid,proto3" json:"job_uuid,omitempty"`
}

func (m *StartJobResponse) Reset()         { *m = StartJobResponse{} }
func (m *StartJobResponse) String() string { return proto.CompactTextString(m) }
func (*StartJobResponse) ProtoMessage()    {}
func (*StartJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4fc5f638932919ca, []int{2}
}
func (m *StartJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartJobResponse.Merge(m, src)
}
func (m *StartJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *StartJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartJobResponse proto.InternalMessageInfo

func (m *StartJobResponse) GetJobUUID() string {
	if m != nil {
		return m.JobUUID
	}
	return ""
}

type StopJobRequest struct {
	JobUUID string `protobuf:"bytes,1,opt,name=job_uuid,json=jobUuid,proto3" json:"job_uuid,omitempty"`
}

func (m *StopJobRequest) Reset()         { *m = StopJobRequest{} }
func (m *StopJobRequest) String() string { return proto.CompactTextString(m) }
func (*StopJobRequest) ProtoMessage()    {}
func (*StopJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4fc5f638932919ca, []int{3}
}
func (m *StopJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StopJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StopJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StopJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopJobRequest.Merge(m, src)
}
func (m *StopJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *StopJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StopJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StopJobRequest proto.InternalMessageInfo

func (m *StopJobRequest) GetJobUUID() string {
	if m != nil {
		return m.JobUUID
	}
	return ""
}

type StopJobResponse struct {
}

func (m *StopJobResponse) Reset()         { *m = StopJobResponse{} }
func (m *StopJobResponse) String() string { return proto.CompactTextString(m) }
func (*StopJobResponse) ProtoMessage()    {}
func (*StopJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4fc5f638932919ca, []int{4}
}
func (m *StopJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StopJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StopJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StopJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopJobResponse.Merge(m, src)
}
func (m *StopJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *StopJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StopJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StopJobResponse proto.InternalMessageInfo

type GetJobRequest struct {
	JobUUID  string `protobuf:"bytes,1,opt,name=job_uuid,json=jobUuid,proto3" json:"job_uuid,omitempty"`
	WithLogs bool   `protobuf:"varint,2,opt,name=with_logs,json=withLogs,proto3" json:"with_logs,omitempty"`
}

func (m *GetJobRequest) Reset()         { *m = GetJobRequest{} }
func (m *GetJobRequest) String() string { return proto.CompactTextString(m) }
func (*GetJobRequest) ProtoMessage()    {}
func (*GetJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4fc5f638932919ca, []int{5}
}
func (m *GetJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetJobRequest.Merge(m, src)
}
func (m *GetJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetJobRequest proto.InternalMessageInfo

func (m *GetJobRequest) GetJobUUID() string {
	if m != nil {
		return m.JobUUID
	}
	return ""
}

func (m *GetJobRequest) GetWithLogs() bool {
	if m != nil {
		return m.WithLogs
	}
	return false
}

type GetJobResponse struct {
	Command *CommandSpec         `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
	State   GetJobResponse_State `protobuf:"varint,2,opt,name=state,proto3,enum=jobworker.GetJobResponse_State" json:"state,omitempty"`
	// StateDetails provides additional details about the job's state.
	StateDetails string           `protobuf:"bytes,3,opt,name=state_details,json=stateDetails,proto3" json:"state_details,omitempty"`
	ExitCode     int32            `protobuf:"varint,4,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	StartedAt    *types.Timestamp `protobuf:"bytes,5,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	EndedAt      *types.Timestamp `protobuf:"bytes,6,opt,name=ended_at,json=endedAt,proto3" json:"ended_at,omitempty"`
	// proc(5): "On 64-bit systems, pid_max can be set to any value up to 2^22"
	PID uint32 `protobuf:"varint,7,opt,name=pid,proto3" json:"pid,omitempty"`
	// Populated only if with_logs set to true
	Stdout []string `protobuf:"bytes,8,rep,name=stdout,proto3" json:"stdout,omitempty"`
	Stderr []string `protobuf:"bytes,9,rep,name=stderr,proto3" json:"stderr,omitempty"`
}

func (m *GetJobResponse) Reset()         { *m = GetJobResponse{} }
func (m *GetJobResponse) String() string { return proto.CompactTextString(m) }
func (*GetJobResponse) ProtoMessage()    {}
func (*GetJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4fc5f638932919ca, []int{6}
}
func (m *GetJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetJobResponse.Merge(m, src)
}
func (m *GetJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetJobResponse proto.InternalMessageInfo

func (m *GetJobResponse) GetCommand() *CommandSpec {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *GetJobResponse) GetState() GetJobResponse_State {
	if m != nil {
		return m.State
	}
	return GetJobResponse_UNKNOWN
}

func (m *GetJobResponse) GetStateDetails() string {
	if m != nil {
		return m.StateDetails
	}
	return ""
}

func (m *GetJobResponse) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *GetJobResponse) GetStartedAt() *types.Timestamp {
	if m != nil {
		return m.StartedAt
	}
	return nil
}

func (m *GetJobResponse) GetEndedAt() *types.Timestamp {
	if m != nil {
		return m.EndedAt
	}
	return nil
}

func (m *GetJobResponse) GetPID() uint32 {
	if m != nil {
		return m.PID
	}
	return 0
}

func (m *GetJobResponse) GetStdout() []string {
	if m != nil {
		return m.Stdout
	}
	return nil
}

func (m *GetJobResponse) GetStderr() []string {
	if m != nil {
		return m.Stderr
	}
	return nil
}

type ListJobsRequest struct {
}

func (m *ListJobsRequest) Reset()         { *m = ListJobsRequest{} }
func (m *ListJobsRequest) String() string { return proto.CompactTextString(m) }
func (*ListJobsRequest) ProtoMessage()    {}
func (*ListJobsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4fc5f638932919ca, []int{7}
}
func (m *ListJobsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListJobsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListJobsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListJobsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListJobsRequest.Merge(m, src)
}
func (m *ListJobsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListJobsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListJobsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListJobsRequest proto.InternalMessageInfo

type ListJobsResponse struct {
	JobUUIDs []string `protobuf:"bytes,1,rep,name=job_uuids,json=jobUuids,proto3" json:"job_uuids,omitempty"`
}

func (m *ListJobsResponse) Reset()         { *m = ListJobsResponse{} }
func (m *ListJobsResponse) String() string { return proto.CompactTextString(m) }
func (*ListJobsResponse) ProtoMessage()    {}
func (*ListJobsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4fc5f638932919ca, []int{8}
}
func (m *ListJobsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListJobsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListJobsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListJobsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListJobsResponse.Merge(m, src)
}
func (m *ListJobsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListJobsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListJobsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListJobsResponse proto.InternalMessageInfo

func (m *ListJobsResponse) GetJobUUIDs() []string {
	if m != nil {
		return m.JobUUIDs
	}
	return nil
}

func init() {
	proto.RegisterEnum("jobworker.GetJobResponse_State", GetJobResponse_State_name, GetJobResponse_State_value)
	proto.RegisterType((*CommandSpec)(nil), "jobworker.CommandSpec")
	proto.RegisterType((*StartJobRequest)(nil), "jobworker.StartJobRequest")
	proto.RegisterType((*StartJobResponse)(nil), "jobworker.StartJobResponse")
	proto.RegisterType((*StopJobRequest)(nil), "jobworker.StopJobRequest")
	proto.RegisterType((*StopJobResponse)(nil), "jobworker.StopJobResponse")
	proto.RegisterType((*GetJobRequest)(nil), "jobworker.GetJobRequest")
	proto.RegisterType((*GetJobResponse)(nil), "jobworker.GetJobResponse")
	proto.RegisterType((*ListJobsRequest)(nil), "jobworker.ListJobsRequest")
	proto.RegisterType((*ListJobsResponse)(nil), "jobworker.ListJobsResponse")
}

func init() { proto.RegisterFile("jobworker.proto", fileDescriptor_4fc5f638932919ca) }

var fileDescriptor_4fc5f638932919ca = []byte{
	// 676 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x5f, 0x4f, 0xd3, 0x50,
	0x14, 0x5f, 0x29, 0x5b, 0xdb, 0x33, 0x06, 0xf5, 0x3e, 0x90, 0x32, 0x92, 0x8d, 0xd4, 0xc4, 0xcc,
	0x07, 0x87, 0xc1, 0x90, 0xa8, 0x09, 0x89, 0x6c, 0x9d, 0x64, 0x38, 0xcb, 0xd2, 0x6d, 0x92, 0xf8,
	0xb2, 0xb4, 0xeb, 0xb5, 0x14, 0xd9, 0xee, 0xec, 0xbd, 0x15, 0x3f, 0x86, 0x4f, 0x7e, 0x26, 0x1f,
	0x79, 0xf4, 0x89, 0x98, 0xf1, 0x45, 0xcc, 0xbd, 0x6d, 0xd9, 0x46, 0x30, 0xca, 0x53, 0xef, 0xf9,
	0x9d, 0xdf, 0xf9, 0xff, 0x2b, 0x6c, 0x9c, 0x13, 0xef, 0x92, 0x44, 0x9f, 0x71, 0x54, 0x9f, 0x46,
	0x84, 0x11, 0xa4, 0xdd, 0x02, 0xe5, 0x6a, 0x40, 0x48, 0x70, 0x81, 0x77, 0x85, 0xc3, 0x8b, 0x3f,
	0xed, 0xb2, 0x70, 0x8c, 0x29, 0x73, 0xc7, 0xd3, 0x84, 0x5b, 0x7e, 0x16, 0x84, 0xec, 0x2c, 0xf6,
	0xea, 0x23, 0x32, 0xde, 0x0d, 0x48, 0x40, 0xe6, 0x4c, 0x6e, 0x09, 0x43, 0xbc, 0x12, 0xba, 0x39,
	0x84, 0x62, 0x93, 0x8c, 0xc7, 0xee, 0xc4, 0xef, 0x4d, 0xf1, 0x08, 0x19, 0xa0, 0x8c, 0x12, 0xd3,
	0x90, 0x76, 0xa4, 0x9a, 0xe6, 0x64, 0x26, 0x42, 0xb0, 0xea, 0x46, 0x01, 0x35, 0x56, 0x76, 0xe4,
	0x9a, 0xe6, 0x88, 0x37, 0xd2, 0x41, 0xc6, 0x93, 0xaf, 0x86, 0x2c, 0x20, 0xfe, 0xe4, 0x88, 0x1f,
	0x46, 0xc6, 0xaa, 0x88, 0xe5, 0x4f, 0xb3, 0x09, 0x1b, 0x3d, 0xe6, 0x46, 0xec, 0x98, 0x78, 0x0e,
	0xfe, 0x12, 0x63, 0xca, 0xd0, 0xf3, 0xe5, 0x22, 0xc5, 0xbd, 0xcd, 0xfa, 0x7c, 0xe2, 0x85, 0x6e,
	0x6e, 0x8b, 0x9b, 0xaf, 0x41, 0x9f, 0x27, 0xa1, 0x53, 0x32, 0xa1, 0x18, 0x3d, 0x01, 0xf5, 0x9c,
	0x78, 0xc3, 0x38, 0x0e, 0xd3, 0x5e, 0x1b, 0xc5, 0xd9, 0x75, 0x55, 0x39, 0x26, 0xde, 0x60, 0xd0,
	0xb6, 0x1c, 0xe5, 0x9c, 0x78, 0x83, 0x38, 0xf4, 0xcd, 0x97, 0xb0, 0xde, 0x63, 0x64, 0xba, 0x50,
	0xff, 0x7f, 0x23, 0x1f, 0xf1, 0xd6, 0xd3, 0xc8, 0xa4, 0xa8, 0xd9, 0x87, 0xd2, 0x11, 0x66, 0x0f,
	0xcf, 0x85, 0xb6, 0x41, 0xbb, 0x0c, 0xd9, 0xd9, 0xf0, 0x82, 0x88, 0x1d, 0x4a, 0x35, 0xd5, 0x51,
	0x39, 0xd0, 0x21, 0x01, 0x35, 0xaf, 0x64, 0x58, 0xcf, 0xd2, 0xa6, 0xd3, 0x3d, 0x78, 0x47, 0x68,
	0x1f, 0xf2, 0x94, 0xb9, 0x0c, 0x8b, 0xec, 0xeb, 0x7b, 0xd5, 0x05, 0xfe, 0x72, 0xee, 0x7a, 0x8f,
	0xd3, 0x9c, 0x84, 0x8d, 0x1e, 0x43, 0x49, 0x3c, 0x86, 0x3e, 0x66, 0x6e, 0x78, 0x41, 0x0d, 0x59,
	0xdc, 0x6e, 0x4d, 0x80, 0x56, 0x82, 0xf1, 0xee, 0xf1, 0xb7, 0x90, 0x0d, 0x47, 0xc4, 0xc7, 0xe2,
	0xb8, 0x79, 0x47, 0xe5, 0x40, 0x93, 0xf8, 0x18, 0xbd, 0x02, 0xa0, 0xfc, 0x38, 0xd8, 0x1f, 0xba,
	0xcc, 0xc8, 0x8b, 0x6e, 0xcb, 0xf5, 0x44, 0xa7, 0xf5, 0x4c, 0x7d, 0xf5, 0x7e, 0xa6, 0x53, 0x47,
	0x4b, 0xd9, 0x87, 0x0c, 0xed, 0x83, 0x8a, 0x27, 0x7e, 0x12, 0x58, 0xf8, 0x67, 0xa0, 0x22, 0xb8,
	0x87, 0x0c, 0x6d, 0x81, 0x3c, 0x0d, 0x7d, 0x43, 0xd9, 0x91, 0x6a, 0xa5, 0x86, 0x32, 0xbb, 0xae,
	0xca, 0xdd, 0xb6, 0xe5, 0x70, 0x0c, 0x6d, 0x42, 0x81, 0x32, 0x9f, 0xc4, 0xcc, 0x50, 0x85, 0x2a,
	0x53, 0x2b, 0xc5, 0x71, 0x14, 0x19, 0xda, 0x2d, 0x8e, 0xa3, 0xc8, 0xfc, 0x00, 0x79, 0xb1, 0x0e,
	0x54, 0x04, 0x65, 0x60, 0xbf, 0xb3, 0x4f, 0x4e, 0x6d, 0x3d, 0xc7, 0x0d, 0x67, 0x60, 0xdb, 0x6d,
	0xfb, 0x48, 0x97, 0x50, 0x09, 0xb4, 0xe6, 0xc9, 0xfb, 0x6e, 0xa7, 0xd5, 0x6f, 0x59, 0xfa, 0x0a,
	0xf7, 0xf5, 0xfa, 0x27, 0xdd, 0x6e, 0xcb, 0xd2, 0x65, 0x04, 0x50, 0x78, 0x7b, 0xd8, 0xee, 0xb4,
	0x2c, 0x7d, 0x95, 0x3b, 0xba, 0x2d, 0xdb, 0xe2, 0x41, 0x79, 0xae, 0x9d, 0x4e, 0x48, 0xf9, 0xda,
	0x69, 0x2a, 0x15, 0xf3, 0x00, 0xf4, 0x39, 0x94, 0x9e, 0xf9, 0x29, 0x68, 0x99, 0x7c, 0xa8, 0x21,
	0xf1, 0xce, 0x1a, 0x6b, 0xb3, 0xeb, 0xaa, 0x9a, 0xea, 0x87, 0x3a, 0x6a, 0x2a, 0x20, 0xba, 0xf7,
	0x63, 0x05, 0xb4, 0x63, 0xe2, 0x9d, 0x8a, 0x93, 0xa2, 0x26, 0xa8, 0xd9, 0x1f, 0x81, 0xca, 0x0b,
	0xa7, 0xbe, 0xf3, 0xaf, 0x95, 0xb7, 0xef, 0xf5, 0xa5, 0xd5, 0xdf, 0x80, 0x92, 0x0a, 0x1c, 0x6d,
	0x2d, 0xf1, 0x16, 0x7f, 0x97, 0x72, 0xf9, 0x3e, 0x57, 0x9a, 0xe1, 0x00, 0x0a, 0x89, 0xb8, 0x90,
	0x71, 0x8f, 0xde, 0x92, 0xf8, 0xad, 0xbf, 0x2a, 0x91, 0x4f, 0x91, 0xad, 0x64, 0x69, 0x8a, 0x3b,
	0xab, 0x5b, 0x9a, 0xe2, 0xee, 0x0e, 0x1b, 0xd5, 0x9f, 0xb3, 0x8a, 0x74, 0x35, 0xab, 0x48, 0xbf,
	0x67, 0x15, 0xe9, 0xfb, 0x4d, 0x25, 0x77, 0x75, 0x53, 0xc9, 0xfd, 0xba, 0xa9, 0xe4, 0x3e, 0xe6,
	0x13, 0x11, 0x15, 0xc4, 0xe7, 0xc5, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x68, 0x92, 0x78, 0x57,
	0x58, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// JobWorkerClient is the client API for JobWorker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type JobWorkerClient interface {
	StartJob(ctx context.Context, in *StartJobRequest, opts ...grpc.CallOption) (*StartJobResponse, error)
	StopJob(ctx context.Context, in *StopJobRequest, opts ...grpc.CallOption) (*StopJobResponse, error)
	GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*GetJobResponse, error)
	// ListJobs returns a list of jobs started by the caller.
	ListJobs(ctx context.Context, in *ListJobsRequest, opts ...grpc.CallOption) (*ListJobsResponse, error)
}

type jobWorkerClient struct {
	cc *grpc.ClientConn
}

func NewJobWorkerClient(cc *grpc.ClientConn) JobWorkerClient {
	return &jobWorkerClient{cc}
}

func (c *jobWorkerClient) StartJob(ctx context.Context, in *StartJobRequest, opts ...grpc.CallOption) (*StartJobResponse, error) {
	out := new(StartJobResponse)
	err := c.cc.Invoke(ctx, "/jobworker.JobWorker/StartJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobWorkerClient) StopJob(ctx context.Context, in *StopJobRequest, opts ...grpc.CallOption) (*StopJobResponse, error) {
	out := new(StopJobResponse)
	err := c.cc.Invoke(ctx, "/jobworker.JobWorker/StopJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobWorkerClient) GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*GetJobResponse, error) {
	out := new(GetJobResponse)
	err := c.cc.Invoke(ctx, "/jobworker.JobWorker/GetJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobWorkerClient) ListJobs(ctx context.Context, in *ListJobsRequest, opts ...grpc.CallOption) (*ListJobsResponse, error) {
	out := new(ListJobsResponse)
	err := c.cc.Invoke(ctx, "/jobworker.JobWorker/ListJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobWorkerServer is the server API for JobWorker service.
type JobWorkerServer interface {
	StartJob(context.Context, *StartJobRequest) (*StartJobResponse, error)
	StopJob(context.Context, *StopJobRequest) (*StopJobResponse, error)
	GetJob(context.Context, *GetJobRequest) (*GetJobResponse, error)
	// ListJobs returns a list of jobs started by the caller.
	ListJobs(context.Context, *ListJobsRequest) (*ListJobsResponse, error)
}

// UnimplementedJobWorkerServer can be embedded to have forward compatible implementations.
type UnimplementedJobWorkerServer struct {
}

func (*UnimplementedJobWorkerServer) StartJob(ctx context.Context, req *StartJobRequest) (*StartJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartJob not implemented")
}
func (*UnimplementedJobWorkerServer) StopJob(ctx context.Context, req *StopJobRequest) (*StopJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopJob not implemented")
}
func (*UnimplementedJobWorkerServer) GetJob(ctx context.Context, req *GetJobRequest) (*GetJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}
func (*UnimplementedJobWorkerServer) ListJobs(ctx context.Context, req *ListJobsRequest) (*ListJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListJobs not implemented")
}

func RegisterJobWorkerServer(s *grpc.Server, srv JobWorkerServer) {
	s.RegisterService(&_JobWorker_serviceDesc, srv)
}

func _JobWorker_StartJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobWorkerServer).StartJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jobworker.JobWorker/StartJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobWorkerServer).StartJob(ctx, req.(*StartJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobWorker_StopJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobWorkerServer).StopJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jobworker.JobWorker/StopJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobWorkerServer).StopJob(ctx, req.(*StopJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobWorker_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobWorkerServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jobworker.JobWorker/GetJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobWorkerServer).GetJob(ctx, req.(*GetJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobWorker_ListJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobWorkerServer).ListJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jobworker.JobWorker/ListJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobWorkerServer).ListJobs(ctx, req.(*ListJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _JobWorker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "jobworker.JobWorker",
	HandlerType: (*JobWorkerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartJob",
			Handler:    _JobWorker_StartJob_Handler,
		},
		{
			MethodName: "StopJob",
			Handler:    _JobWorker_StopJob_Handler,
		},
		{
			MethodName: "GetJob",
			Handler:    _JobWorker_GetJob_Handler,
		},
		{
			MethodName: "ListJobs",
			Handler:    _JobWorker_ListJobs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "jobworker.proto",
}

func (m *CommandSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dir) > 0 {
		i -= len(m.Dir)
		copy(dAtA[i:], m.Dir)
		i = encodeVarintJobworker(dAtA, i, uint64(len(m.Dir)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Env) > 0 {
		for iNdEx := len(m.Env) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Env[iNdEx])
			copy(dAtA[i:], m.Env[iNdEx])
			i = encodeVarintJobworker(dAtA, i, uint64(len(m.Env[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintJobworker(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Command) > 0 {
		i -= len(m.Command)
		copy(dAtA[i:], m.Command)
		i = encodeVarintJobworker(dAtA, i, uint64(len(m.Command)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Command != nil {
		{
			size, err := m.Command.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintJobworker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobUUID) > 0 {
		i -= len(m.JobUUID)
		copy(dAtA[i:], m.JobUUID)
		i = encodeVarintJobworker(dAtA, i, uint64(len(m.JobUUID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StopJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StopJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobUUID) > 0 {
		i -= len(m.JobUUID)
		copy(dAtA[i:], m.JobUUID)
		i = encodeVarintJobworker(dAtA, i, uint64(len(m.JobUUID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StopJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StopJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithLogs {
		i--
		if m.WithLogs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.JobUUID) > 0 {
		i -= len(m.JobUUID)
		copy(dAtA[i:], m.JobUUID)
		i = encodeVarintJobworker(dAtA, i, uint64(len(m.JobUUID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Stderr) > 0 {
		for iNdEx := len(m.Stderr) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Stderr[iNdEx])
			copy(dAtA[i:], m.Stderr[iNdEx])
			i = encodeVarintJobworker(dAtA, i, uint64(len(m.Stderr[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Stdout) > 0 {
		for iNdEx := len(m.Stdout) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Stdout[iNdEx])
			copy(dAtA[i:], m.Stdout[iNdEx])
			i = encodeVarintJobworker(dAtA, i, uint64(len(m.Stdout[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.PID != 0 {
		i = encodeVarintJobworker(dAtA, i, uint64(m.PID))
		i--
		dAtA[i] = 0x38
	}
	if m.EndedAt != nil {
		{
			size, err := m.EndedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintJobworker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.StartedAt != nil {
		{
			size, err := m.StartedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintJobworker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ExitCode != 0 {
		i = encodeVarintJobworker(dAtA, i, uint64(m.ExitCode))
		i--
		dAtA[i] = 0x20
	}
	if len(m.StateDetails) > 0 {
		i -= len(m.StateDetails)
		copy(dAtA[i:], m.StateDetails)
		i = encodeVarintJobworker(dAtA, i, uint64(len(m.StateDetails)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintJobworker(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Command != nil {
		{
			size, err := m.Command.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintJobworker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListJobsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListJobsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListJobsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListJobsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListJobsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListJobsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobUUIDs) > 0 {
		for iNdEx := len(m.JobUUIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.JobUUIDs[iNdEx])
			copy(dAtA[i:], m.JobUUIDs[iNdEx])
			i = encodeVarintJobworker(dAtA, i, uint64(len(m.JobUUIDs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintJobworker(dAtA []byte, offset int, v uint64) int {
	offset -= sovJobworker(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CommandSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovJobworker(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovJobworker(uint64(l))
		}
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovJobworker(uint64(l))
		}
	}
	l = len(m.Dir)
	if l > 0 {
		n += 1 + l + sovJobworker(uint64(l))
	}
	return n
}

func (m *StartJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovJobworker(uint64(l))
	}
	return n
}

func (m *StartJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobUUID)
	if l > 0 {
		n += 1 + l + sovJobworker(uint64(l))
	}
	return n
}

func (m *StopJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobUUID)
	if l > 0 {
		n += 1 + l + sovJobworker(uint64(l))
	}
	return n
}

func (m *StopJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobUUID)
	if l > 0 {
		n += 1 + l + sovJobworker(uint64(l))
	}
	if m.WithLogs {
		n += 2
	}
	return n
}

func (m *GetJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovJobworker(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovJobworker(uint64(m.State))
	}
	l = len(m.StateDetails)
	if l > 0 {
		n += 1 + l + sovJobworker(uint64(l))
	}
	if m.ExitCode != 0 {
		n += 1 + sovJobworker(uint64(m.ExitCode))
	}
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovJobworker(uint64(l))
	}
	if m.EndedAt != nil {
		l = m.EndedAt.Size()
		n += 1 + l + sovJobworker(uint64(l))
	}
	if m.PID != 0 {
		n += 1 + sovJobworker(uint64(m.PID))
	}
	if len(m.Stdout) > 0 {
		for _, s := range m.Stdout {
			l = len(s)
			n += 1 + l + sovJobworker(uint64(l))
		}
	}
	if len(m.Stderr) > 0 {
		for _, s := range m.Stderr {
			l = len(s)
			n += 1 + l + sovJobworker(uint64(l))
		}
	}
	return n
}

func (m *ListJobsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListJobsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JobUUIDs) > 0 {
		for _, s := range m.JobUUIDs {
			l = len(s)
			n += 1 + l + sovJobworker(uint64(l))
		}
	}
	return n
}

func sovJobworker(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozJobworker(x uint64) (n int) {
	return sovJobworker(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CommandSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &CommandSpec{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobUUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobUUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobUUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobUUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobUUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobUUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithLogs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithLogs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJobworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &CommandSpec{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= GetJobResponse_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateDetails", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateDetails = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &types.Timestamp{}
			}
			if err := m.StartedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndedAt == nil {
				m.EndedAt = &types.Timestamp{}
			}
			if err := m.EndedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			m.PID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stdout = append(m.Stdout, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stderr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stderr = append(m.Stderr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListJobsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListJobsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListJobsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListJobsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobworker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListJobsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListJobsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobUUIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobworker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJobworker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobUUIDs = append(m.JobUUIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobworker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJobworker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipJobworker(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowJobworker
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJobworker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthJobworker
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupJobworker
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthJobworker
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthJobworker        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowJobworker          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupJobworker = fmt.Errorf("proto: unexpected end of group")
)
